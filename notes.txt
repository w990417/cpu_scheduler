BOOKMARK:
<0525>
modifying CPU() to...
1. check running_p
2. assign new process to running_p if NULL
3. compute for 1 CLK cycle
4. check if running_p is done
5. send to term_q if done
** check the cycle note below for details.

TODO: 
<0524>
struct Eval
evaluate(): modify to return an eval struct type which contain
    time related attributes for all processes + avg + sums,
    which can be searched up with user input.

<0525>
global var `log` and `log_idx`
 - log: array of strings
 - log_idx: index of log array

e.g:
void addToLog(const char* message) {
  strncpy(log[nextLogEntry], message, sizeof(log[nextLogEntry]) - 1);
  log[nextLogEntry][sizeof(log[nextLogEntry]) - 1] = '\0';  // Ensure null-termination
  nextLogEntry++;
}
>> addToLog("[PID: 9441] is scheduled at clk=5");

print_log() function

*malloc on ...
==============
create_process() --> (Process**) new_pool
_create_process() --> (Process*) new processes


create_table() --> (Table*) new_table (self)
    - also calls create_queue() for wait, term queues and ready/priority queues
    - if priority queues are used, (Queue**) prio_q is created (which is a queue of queues)
create_queue() --> (Queue*) new queues

enqueue() --> (Node*) new_node


*free on ...
============
dequeue() --> (Node*) Node of the process that is dequeued


* when implementing I/O ...
===========================
maybe implement CPU and I/O burst as an array of length (cpu_burst + io_burst)
[1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1 ...] etc.
where 1 is CPU burst and 0 is I/O burst

when Process's state is 2 (running) or i/o-waiting (not assigned yet), pop the array etc.

can't pop an array like a list in python tho so.. maybe use a pointer to the array and increment it
when the process is running or i/o-waiting..? 

!TBD!



* CLK cycle ...
==========================================

--- CLK=t ---

[arrival check]: arrive @ CLK=t

[CPU check]: check if there is a process running on CPU
 - true: do nothing (keep process)
 - false: scheduler() assigns a new process to CPU (assign @ CLK=t)

[CPU compute]: compute for 1 CLK cycle (CLK=t)

[CPU check]: check if process is done
 - true: terminate process (finished @ CLK=t)
 - false: do nothing (keep process)

[All done check]: check if all processes are done
 - true: finished @ CLK=t
 - false: ready queue wait time incremented --> waited during CLK=t

[CPU check]: check if process should be preempted
 - TODO: preemption not implemented yet
 
update CLK=t+1

--- CLK=t+1 ---




[finished check]
- check if new_pool is empty AND term_q count == num_process --> done. Stop loop.
- check if there are new arrivals in new_pool --> enqueue() to ready_q

[running_p check]
- update burst time (cpu_burst, io_burst) of running_p (and i/o waiting when implemented)
- check running_p (and i/o waiting when implemented) --> if done, terminate and enqueue() to term_q
- check if running_p is NULL --> scheduler() assigns a new process to running_p
    - if scheduler() returns NULL, (but not done yet) --> idle time. (increment idle_time if implement)